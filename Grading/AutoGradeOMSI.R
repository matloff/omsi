
# script to semi-automate quiz grading; see HOW TO RUN below for an
# overview

# note too the conversion of group quiz records at the end

# HOW TO RUN:

#    the term "top directory" will mean the OMSI student file directory,
#    which has a subdirectory for each student, named after the
#    student's e-mail address

#    place the PtsCmds file in the top directory; see INFO FILE BELOW

#    start R in the top directory, and run this script

#    set any global variables that might be needed for some of the problems

#    call grader(), which will loop through the students, facilitating
#    the instructor's grading of each, with the scripting prompting the
#    instructor and recording his/her grade; the results will be saved
#    continuously to a file "outfile"

#    after all students are graded, the script will:

#       offer the instructor a chance to make corrections
#       display the results for all students on the screen

#    call calcltrgrades() to compute the letter grades; it will:

#       display the student grades from outfile
#       display a table of score frequencies
#       prompt the instructor to input the cutoff values for the letter grades
#       calculate the letter grades
#       rewrite outfile, with letter grades now added
#       write the results to the file Quizn

#    call emailresults() to mail out the results; it inputs from outfile

# INFO FILE:

# The instructor places a file PtsCmds in the top
# directory, with format, for Question i

#   %file_name_for_Quest_i  point_total-_for_Quest_i 
#   command line, beginning with $; can be empty other than the $

# Example:
#    % omsi_answer3.py 10
#    $ python omsi_answer3.py

# Here Problem 3 is worth 10 points.  The student's answer, which OMSI
# will have placed in the file omsi_answer3.py, is to be run through
# python.

# Example:
#    % 1.R 20
#    $ cp 1.R nm1.R; echo 'f(3)' >> nm1.R; Rscript nm1.R

# Here Problem 1, worth 20 points, is in the file 1.R (not generated by
# OMSI).  The contents of the file is a function f().  To test it, we
# evaluate f(3), to be accomplished by making a copy of 1.R to nm1.R and
# appending a line with f(3), then running through Rscript.

# Example:

#    % Prob3.R 30
#    $ cp Prob3.R nm.R; cat ../NMProb3.R >> nm.R; Rscript nm.R
    
#    n <- 1000
#    x <- rexp(n)
#    png('nm.png')
#    plotestcdf(x,5)
#    dev.off()
#    browseURL('nm.png')

# Here we want to do plotting.  Some manipulation is needed to get the
# plot to come up.

# GLOBALS
#
#    testid:  exam number
#    nproblems:  number of problems
#    pttots:  numbers of points for the problems
#    cmnds:  what to run for each problem
#    studentfilenames:  names of the student answer files; set by OMSI
#       at the time of the exam
#    output:  quiz results minus letter grades (latter are not yet determined) 

# splits s account to '', returning the nonempty fields in a character
# vector
getnonblankfields <- function(s) {
   tmp <- strsplit(s,split=' ')[[1]]
   tmp[tmp != ''] 
}

# read instructor's PtsCmds file, setting point totals and commands, and
# the student answer file names
getkey <- function() {
   lines <- readLines('PtsCmds')
   nlines <- length(lines)
   if (nlines %% 2 != 0) stop('file has odd number of lines')
   nproblems <<- nlines / 2
   pttots <<- vector(length=nproblems)
   studentfilenames <<- vector(length=nproblems)
   cmnds <<- vector(length=nproblems)
   for (i in 1:nproblems) {
      ptline <- lines[2*i-1]
      tmp <- getnonblankfields(ptline)
      if (tmp[1] != '%') stop('expected %')
      studentfilenames[i] <<- tmp[2]
      tmp <- as.numeric(tmp[3])
      if (is.na(tmp)) stop('nonnumeric point total')
      pttots[i] <<-  as.numeric(tmp)
      cmdline <- lines[2*i]
      tmp <- getnonblankfields(cmdline)
      if (substr(cmdline,1,1) != '$') stop('expected $')
      lcmd <- nchar(cmdline)
      if (lcmd == 1) {
         cmnds[i] <<- NA
      } else cmnds[i] <<- substr(cmdline,2,nchar(cmdline))
   }
}

waitenter <- function() {
   resp <- readline('hit Enter when ready')
}

# grade the i-th problem 
gradestudentans <- function(i) {
   sfl <- studentfilenames[i]
   flsHere <- list.files()
   if (!sfl %in% flsHere) {
      cat(sfl,'not present\n')
      print('similar files')
      tmp <- strsplit(sfl,'.',fixed=TRUE)[[1]][1]
      cmd <- paste('ls ',tmp,'.*',sep='')
      print(system(cmd))
      return(0)
   }
   # try cmd, wait for instructor to hit Enter
   if (!is.na(cmnds[i])) {
      system(cmnds[i],timeout=10)
      waitenter()
   }
   # display user text
   lines <- readLines(sfl)
   for (l in lines) {
      if (l != '') cat(l,'\n')
   }
   fullpts <- pttots[i]
   resp <- readline(paste("pts out of ",fullpts, "? [empty means full pts] "))
   if (resp == "") pts <- fullpts else pts <- resp
   pts
}

grader <- function() {
   setwd('StudentFiles')
   topdir <- getwd()  # 4/18/23
   on.exit(setwd(topdir))
   testid <<- readline("enter test ID: ") 
   # set up R list that will contain the true answers
   getkey()  
   output <<- vector(mode="character")
   # loop across all student directories
   for (emailaddr in list.dirs(full.names=FALSE,recursive=FALSE)) {  
      if (emailaddr == '') next
      cat("\n\n","  now grading",emailaddr,"\n")
      setwd(emailaddr)
      # start to build the output line for this student; it will consist
      # of e-mail address, the student's score for each problem, etc.
      outputline <- emailaddr
      total <- 0
      # start grading the problems
      for (i in 1:nproblems) {
         cat('\n\nProblem',i,'\n\n')
         score <- gradestudentans(i)
         outputline <- 
            paste(outputline," ", score,"/",pttots[i],sep="")
         total <- total + as.integer(score)
      }
      outputline <- paste(outputline,"total =",total)
      print(outputline)
      output <<- c(output,outputline)
      # save output after each student, so as to not have to start all
      # over again if the script crashes; then can do the rest
      # separately
      # back up
      setwd(topdir)
      save(output,file="outfile")
   }
   # the instructor now has a chance to make corrections to the
   # scores/grades
   repeat {
      resp <- readline("need to edit? ")
      if (resp  == "y" || resp == 'n') break
   }
   if (resp  == "y") {
      output <<- edit(output)
      save(output,file="outfile")
   } 
   # print the results (still no letter grade) to screen and the file
   # "outfile"
   cat("\n","results:","\n")
   for (i in 1:length(output)) {
      cat(output[i],"\n")
   }
}

# inputs a character vector svec, each element of which has the same 
# number of blanks, and then forms a data frame from the nonblank fields
splittodf <- function(svec) {
   nr <- length(svec)
   rslt <- strsplit(svec[1],split=" ")[[1]]
   for (i in 2:nr) {
       sp <- strsplit(svec[i],split=" ")[[1]]
       rslt <- rbind(rslt,sp)
   }
   rslt <- data.frame(rslt)
   rownames(rslt) <- 1:nr
   rslt
}

calcltrgrades <- function() {
   load("outfile")
   # may be on another machine, so ask again
   testid <<- readline("enter test ID: ") 
   gdf <- splittodf(output)
   print(gdf)
   print(table(gdf[,ncol(gdf)]))
   tmp <- readline("enter cutoffs (none for F), e.g. 95 A+ 85 A 70 B...: ")
   tmp <- strsplit(tmp," ")[[1]]
   inds <- 1:length(tmp)
   evens <- inds[inds %% 2 == 0]
   odds <- inds[inds %% 2 == 1]
   ltrgrades <- tmp[evens]
   cutoffs <- as.integer(tmp[odds])
   totcol <- length(strsplit(output[1]," ")[[1]]) 
   for (i in 1:length(output)) {
      total <- strsplit(output[i]," ")[[1]][totcol]
      total <- as.integer(total)
      ltrgrd <- num2ltr(total,cutoffs,ltrgrades)
      output[i] <- paste(output[i],ltrgrd)
   }
   # save to file for records
   save(output,file="outfile")
   write(output,file=paste("../Quiz",testid,"Grades",sep=""))
   cat("\n","  letter grade results:","\n")
   for (i in 1:length(output)) {
      cat(output[i],"\n")
   }
   print("if not in office, upload outfile, QuiznGrades, Answersn, .tex")
}

emailresults <- function(coursename) {
   # if sending mail requires a password, remind the user
   # readline("set password externally (if any), then hit Enter")
   load("outfile")
   for (l in output) {
      tmp <- strsplit(l," ")[[1]]
      emailaddr <- tmp[1]
      # emailaddr <- paste(emailaddr,"@ucdavis.edu",sep="")
      cat(l,file="onestudent")
      subject <- paste(coursename,'Quiz',testid,'results',sep=" ")
      # tosend <- paste("mutt",emailaddr,"-s 'quiz results' < onestudent")
      tosend <- paste("mutt",emailaddr,"-s '", subject, "' < onestudent")
      # tosend <- paste('mail -s "quiz results" ',emailaddr, ' < onestudent')
      system(tosend)
      print(tosend)
      print(l)
      system("sleep 10")
      system("/bin/rm onestudent")
   }
}

# determines the letter gradeoff, based on the cutoffs cuts,lgs
num2ltr <- function(tot,cuts,lgs) {
   for (i in 1:length(cuts)) {
      if (tot >= cuts[i]) return(lgs[i])
   }
   return("F")
}

topdir <<- getwd()

# takes the global variable 'output', one line per group, of the form

#    ajones.bsmith@ucdavis.edu scores.and.grade

# and outputs one line per group member, e.g.

#    ajones@ucdavis.edu scores.and.grade

convertGrpQuizRecord <- function() {
   outputIndiv <<- NULL
   for (il in output) {
      ucdPos <- gregexpr('ucd',il)[[1]][1]
      if (ucdPos == -1) {
         cat('error: ',il,'\n')
         next
      }
      grp <- substr(il,1,ucdPos-2)
      members <- strsplit(grp,'.',fix=TRUE)[[1]]
      # no '.'s?
      if (length(members) == length(grp)) {
         cat('error: ',il,'\n')
         next
      }
      restOfLine <- substr(il,ucdPos+12,nchar(il))
      ucd <- '@ucdavis.edu'
      for (m in members) {
         m <- paste0(m,ucd,' ',restOfLine)
         outputIndiv <<- c(outputIndiv,m)
      }
   }
   output <- outputIndiv
   save(output,file='outfile')
   write(output,file=paste("../Quiz",testid,"Grades",sep=""))
   output
}



